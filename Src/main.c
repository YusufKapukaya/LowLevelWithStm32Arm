/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2024 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include <stdint.h>
#include "stm32.h"
#include "ARMCORE.h"
#include "GPIO.h"
#include "RNG.h"
#include "TIMER.h"



#define		GPIO_ARRAY_SIZE		4

int main(void)
{
	/*
	GPIO_Handle_e led_blue={GPIOD,{GPIO_MODE_OUTPUT,GPIO_OTYPE_PP,GPIO_OSPEEDR_MEDIUM,GPIO_PUPDR_NOPUPD,NO_ALTERNATE_FUNC,LED_Blue}};
	gpioInit(&led_blue);
	gpioWritePin(GPIOD,15,1);

	GPIO_Handle_t led_green={GPIOD,{GPIO_MODE_OUTPUT,GPIO_OTYPE_PP,GPIO_OSPEEDR_MEDIUM,GPIO_PUPDR_NOPUPD,NO_ALTERNATE_FUNC,LED_GREEN}};
	GPIO_Handle_t led_orange={GPIOD,{GPIO_MODE_OUTPUT,GPIO_OTYPE_PP,GPIO_OSPEEDR_MEDIUM,GPIO_PUPDR_NOPUPD,NO_ALTERNATE_FUNC,LED_ORANGE}};
	GPIO_Handle_t led_red={GPIOD,{GPIO_MODE_OUTPUT,GPIO_OTYPE_PP,GPIO_OSPEEDR_MEDIUM,GPIO_PUPDR_NOPUPD,NO_ALTERNATE_FUNC,LED_RED}};
	GPIO_Handle_t led_blue={GPIOD,{GPIO_MODE_OUTPUT,GPIO_OTYPE_PP,GPIO_OSPEEDR_MEDIUM,GPIO_PUPDR_NOPUPD,NO_ALTERNATE_FUNC,LED_BLUE}};

	GPIO_Handle_t *pa[GPIO_ARRAY_SIZE]={&led_green,&led_orange,&led_red,&led_blue};

	for(int i=0;i<4;i++)
		gpio_init(pa[i]);

	for(int i=12;i<16;i++)
	gpioWritePin(GPIOD, i, GPIO_PIN_SET);

	GPIO_Handle_t b1_UserButton={GPIOA,{GPIO_MODE_INPUT,GPIO_OTYPE_PP,GPIO_OSPEEDR_MEDIUM,GPIO_PUPDR_NOPUPD,NO_ALTERNATE_FUNC,GPIO_Pin_0}};
	gpio_init(&b1_UserButton);

	GPIO_Handle_t led_blue={GPIOD,{GPIO_MODE_OUTPUT,GPIO_OTYPE_PP,GPIO_OSPEEDR_MEDIUM,GPIO_PUPDR_NOPUPD,NO_ALTERNATE_FUNC,LED_BLUE}};
	gpio_init(&led_blue);

	RCC->APB2ENR |=(1U<<14);
	SYSCFG->EXTICR[0] &=~(1U<<0);
	SYSCFG->EXTICR[0] &=~(1U<<1);
	SYSCFG->EXTICR[0] &=~(1U<<2);
	SYSCFG->EXTICR[0] &=~(1U<<3);

	EXTI->RTSR |=(1U<<0);
	EXTI->IMR  |=(1U<<0);

	NVIC_ISER->ISER0 |= (1U<<6);


	GPIO_Handle_t b1_Pin12={GPIOC,{GPIO_MODE_INPUT,GPIO_OTYPE_PP,GPIO_OSPEEDR_MEDIUM,GPIO_PUPDR_NOPUPD,NO_ALTERNATE_FUNC,GPIO_Pin_12}};
	GPIO_Handle_t b1_Pin13={GPIOC,{GPIO_MODE_INPUT,GPIO_OTYPE_PP,GPIO_OSPEEDR_MEDIUM,GPIO_PUPDR_NOPUPD,NO_ALTERNATE_FUNC,GPIO_Pin_13}};
	gpio_init(&b1_Pin12);
	gpio_init(&b1_Pin13);


	GPIO_Handle_e user_pushbutton={GPIOA,{GPIO_MODE_INPUT,GPIO_OTYPE_PP,GPIO_OSPEEDR_MEDIUM,GPIO_PUPDR_NOPUPD,NO_ALTERNATE_FUNC,pinNumber0}};
	gpioInit(&user_pushbutton);

	GPIO_Handle_e led_blue={GPIOD,{GPIO_MODE_OUTPUT,GPIO_OTYPE_PP,GPIO_OSPEEDR_MEDIUM,GPIO_PUPDR_NOPUPD,NO_ALTERNATE_FUNC,LED_Blue}};
	gpioInit(&led_blue);


	SYSCFG->EXTICR[0] &=~(1<<0);
	SYSCFG->EXTICR[0] &=~(1<<1);
	SYSCFG->EXTICR[0] &=~(1<<2);
	SYSCFG->EXTICR[0] &=~(1<<3);
	 */

	GPIO_Handle_e  led_green={GPIOD,{GPIO_MODE_OUTPUT,GPIO_OTYPE_PP,GPIO_OSPEEDR_MEDIUM,GPIO_PUPDR_NOPUPD,NO_ALTERNATE_FUNC,LED_Green}};
	GPIO_Handle_e  led_orange={GPIOD,{GPIO_MODE_OUTPUT,GPIO_OTYPE_PP,GPIO_OSPEEDR_MEDIUM,GPIO_PUPDR_NOPUPD,NO_ALTERNATE_FUNC,LED_Orange}};
	GPIO_Handle_e  led_red={GPIOD,{GPIO_MODE_OUTPUT,GPIO_OTYPE_PP,GPIO_OSPEEDR_MEDIUM,GPIO_PUPDR_NOPUPD,NO_ALTERNATE_FUNC,LED_Red}};
	GPIO_Handle_e  led_blue={GPIOD,{GPIO_MODE_OUTPUT,GPIO_OTYPE_PP,GPIO_OSPEEDR_MEDIUM,GPIO_PUPDR_NOPUPD,NO_ALTERNATE_FUNC,LED_Blue}};

	GPIO_Handle_e  *pa[GPIO_ARRAY_SIZE]={&led_green,&led_orange,&led_red,&led_blue};

	for(int i=0;i<4;i++)
		gpioInit(pa[i]);


	systickConfig(16000);
	timerInit(TIMER_6,10,16000);
	timerInterruptConfig(TIMER_6);
	while(1)
	{

	}
}


//Finite State Mashine
void taskLed()
{
	static enum led_state{
		LED_OFF,
		LED_ON
	}state = LED_OFF;

	static clock_t t0;
	clock_t t1;

	t1=getClock();

	switch(state){
	case LED_OFF:
		if(t1 >= t0+900)
		 {
			gpioWritePin(GPIOD, LED_Blue, GPIO_PIN_SET);
			t0 = t1;
			state = LED_ON;
		 }
		break;
	case LED_ON:
		if(t1 >= t0+100)
		{
			gpioWritePin(GPIOD, LED_Blue, GPIO_PIN_RESET);
			t0 = t1;
			state = LED_OFF;
		}
		break;
	}
}


void TIM6_DAC_IRQHandler(){
	static int counter=0;
	if(TIMER6->SR & (1U<<0))
	{
		if(counter %25==0)
			gpioToggle(GPIOD,LED_Green);
		if(counter %50==0)
			gpioToggle(GPIOD,LED_Orange);
		if(counter %100==0)
			gpioToggle(GPIOD,LED_Blue);
	}
	++counter;
	clearITPendingBitTimer6();
}

void HASH_RNG_IRQHandler(){

	if(!(RNG->SR & RNG_SEIS) && !(RNG->SR & RNG_CEIS) && (RNG->SR & RNG_DRDY))
	{
		static uint32_t temp=0;
		uint32_t g_random_number= RNG->DR;
		if(g_random_number==temp)
			g_random_number=-1;

		temp = g_random_number;
	}
	else{
		if(RNG->SR & RNG_SEIS){
			RNG->SR &=~RNG_SEIS;

			RNG->CR &=~RNG_EN;
			RNG->CR |= RNG_EN;
		}
	}
}

void EXTI0_IRQHandler(){
	if(EXTI->PR &(1U<<0))
	{
		gpioToggle(GPIOD,LED_Blue);
		EXTI->PR |=(1U<<0);
	}
}

